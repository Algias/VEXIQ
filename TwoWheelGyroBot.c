#pragma config(Sensor, port3,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port6,  touchsensor,    sensorVexIQ_LED)
#pragma config(Sensor, port7,  bump,           sensorVexIQ_Touch)
#pragma config(Motor,  motor2,          right,         tmotorVexIQ, PIDControl, driveRight, encoder)
#pragma config(Motor,  motor5,          left,          tmotorVexIQ, PIDControl, reversed, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void reset(); // Reset function prototype
bool debug = true,bumpchange=false,btnChange = false,active=true;
float gyrocurrent;
float tkp = 11.40,tki = 0.073,tkd = 0.75;
float tErrorCurrent = 0, tIntegral = 0, tDerivative = 0, tErrorPrev = 0;
float tiltSet = 0.0;
float vLeft = 0.0, vRight = 0.0, v = 0.0;
int valueselect = 0;
int deltat = 0;

task main()
{
	setMotorBrakeMode(left,motorBrake);
	setMotorBrakeMode(right,motorBrake);
	bUserControlsLCDButtons = true;
	datalogClear();

	while(1){

		clearTimer(T1);

		if (getTouchLEDValue(touchsensor)&&active) //Reset the zeroing setpoint with touch sensor
			reset();

		if (btnChange == false){ //If not already pressed (Button Toggle)
			if(nLCDButtons == 2)
				valueselect = valueselect == 2? 0:valueselect+=1; //Checkmark button sets constant variable
			if(nLCDButtons == 1)
				valueselect == 0 ? tkp+=.05:valueselect == 1 ? tki+=.001:valueselect==2 ? tkd+=.25:NULL; //Increase constant
			if(nLCDButtons == 4)
				valueselect == 0 ? tkp-=.05:valueselect == 1 ? tki-=.001:valueselect==2 ? tkd-=.25:NULL; //Decrease constant
		}
		if (nLCDButtons !=0) //Button is toggled on
			btnChange=true;
		else
			btnChange=false; //Button Toggled off

		if(bumpchange == false) //Bumper not already pressed
		{
			getBumperValue(bump) == 1 ? active = !active:NULL; //Set active / inactive control
		}
		if (getBumperValue(bump) == 1) //Toggle bumper on
			bumpchange=true;
		else
			bumpchange=false; //Toggle Bumper off

		gyrocurrent = getGyroDegreesFloat(gyro); //Get our current gyro value

		tErrorCurrent = (tiltSet - gyrocurrent); //Get error between setpoint and current tilt

		tIntegral+=tErrorCurrent; //Accumulate error

		tDerivative = tErrorCurrent-tErrorPrev; //Change in error

		v = (tErrorCurrent*tkp) + (tIntegral*tki) + (tDerivative*tkd); //Find velocity value
		v = fabs(v)>100 ? 100*sgn(v): floor(v); //Clamp the velocity between -100 and 100
		tErrorPrev = tErrorCurrent; //Set current error as new previous error

		if(active){ //If the control is active
			setTouchLEDBlinkTime(touchsensor, 20, 0); //Set led on
			if(fabs(gyrocurrent) > 50) //If the difference is too great, reset integral and set velocity to 0, red error status
			{
				v = 0;
				tIntegral = 0;
				setTouchLEDColor(touchsensor, colorRed);
			}
			if(fabs(gyrocurrent) > 10 && fabs(gyrocurrent) < 50) //Large error accumulation, becoming outside of threshold, orange status
			{
				setTouchLEDColor(touchsensor,colorOrange);
			}
			if(fabs(gyrocurrent) <10){ //Within good threshold, green status
				setTouchLEDColor(touchsensor,colorGreen);
			}
		}
		else{ //Inactive control
			v=0;
			eraseUserScreenArea();
			displayString(0,"Disabled");
			setTouchLEDColor(touchsensor, colorRed);
			setTouchLEDBlinkTime(touchsensor, 20, 10);
		}
		if(debug && active){ //Control is active and displaying on screen

			displayString(0, "g:%4.3f,state:%d",gyrocurrent,valueselect);
			displayString(1, "e:%6.1f,dt:%d",tErrorCurrent,deltat);
			displayString(2, "v:%4.3f,btn:%d",v,nLCDButtons);
			displayString(3, "p:%4.2f,i:%4.3f,d:%4.2f",tkp,tki,tkd);
			deltat=time1(T1);

		}
		vLeft=vRight=v; //Left and right velocties set to requested velocity
		setMotorSpeed(left, vLeft);
		setMotorSpeed(right, vRight);
	}
}
void reset(){ //Reset state
	resetGyro(gyro);
	clearTimer(T1);
	tErrorCurrent=0;
	tIntegral = 0;
	tDerivative = 0;
	tErrorPrev = 0;
}
